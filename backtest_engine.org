#+LATEX_HEADER: \textwidth=6.6in
#+LATEX_HEADER: \textheight=8.9in
#+LATEX_HEADER: \headheight=0.0in
#+LATEX_HEADER: \oddsidemargin=0.0in
#+LATEX_HEADER: \headsep=0.0in
#+LATEX_HEADER: \topmargin=0.0in
#+LATEX_HEADER: \def\baselinestretch{1.3}
#+LATEX_HEADER_EXTRA: \setCJKmainfont{Songti SC}
#+LATEX_HEADER: \setlength\parindent{0pt}
#+LATEX_HEADER: \lstset{numbers=left,
#+LATEX_HEADER:   basicstyle=\linespread{1.0}\small\ttfamily,
#+LATEX_HEADER:   numberstyle=\tiny, 
#+LATEX_HEADER:   keywordstyle= \color{blue!70},commentstyle=\color{red!50!green!50!blue!50}, 
#+LATEX_HEADER:   frame=shadowbox, 
#+LATEX_HEADER:   rulesepcolor= \color{red!20!green!20!blue!20},
#+LATEX_HEADER:   breaklines=true,
#+LATEX_HEADER:   backgroundcolor=\color[rgb]{0.91,0.91,0.91},
#+LATEX_HEADER:   framextopmargin=2pt,
#+LATEX_HEADER:   framexbottommargin=2pt,
#+LATEX_HEADER:   abovecaptionskip=-3pt,
#+LATEX_HEADER:   belowcaptionskip=3pt,
#+LATEX_HEADER:   xleftmargin=0em,
#+LATEX_HEADER:   xrightmargin=0em
#+LATEX_HEADER: }
#+LATEX_HEADER_EXTRA: \hypersetup{
#+LATEX_HEADER_EXTRA:     colorlinks,
#+LATEX_HEADER_EXTRA:     linkcolor={red!50!black},
#+LATEX_HEADER_EXTRA:     citecolor={blue!50!black},
#+LATEX_HEADER_EXTRA:     urlcolor={blue!80!black}
#+LATEX_HEADER_EXTRA: }

* Download data

#+BEGIN_SRC ipython :preamble "# -*- coding: utf-8 -*-" :results raw drawer :session :async t
  import pandas as pd
  import math
  import ssdata
  import matplotlib.pyplot as plt
  import numpy as np


  ###############################################################################
  #                           Define framework classes                          #
  ###############################################################################


  class account:
      def __init__(self, start_date, end_date, capital_base, freq, benchmark,
                   universe, tax=0.001, commission=0.00025, slippage=0.01):
          """
          start_date: the start date of back test
          end_date: the end date of back test
          capital_base: initial fund to perform back test
          freq: back test frequencies, measured in days, eg. 1 for daily and 7
              for weekly
          tax: tax rate
          commission: commission rate
          slippage: slippage
          """
          self.start_date = start_date
          self.end_date = end_date
          self.capital_base = capital_base
          self.freq = freq
          self.benchmark = benchmark
          self.universe = universe
          self.tax = tax
          self.commission = commission
          self.slippage = slippage

          self.ini_dic = None
          self.benchmark_data = None
          self.trade_days = None
          self.order_days = None
          self.today_capital = None
          self.ret = None
          self.history_max = None
          self.drawdown_start = None
          self.drawdown_end = None
          self.capital = None
          self.cash = None

      def setup(self):
          self.ini_dic = {}
          self.benchmark_data = pd.DataFrame()

          for stock in self.universe:
              try:
                  data = ssdata.get_data(secid=stock,
                                         start_date=self.start_date,
                                         end_date=self.end_date,
                                         field='open,yoyop,pb').dropna().\
                                         sort_index()
                  self.ini_dic[stock] = data
                  print("Succeed: ", stock, self.universe.index(stock)+1, '/',
                        len(self.universe))
              except Exception:
                  print(stock, "data unavailable.", self.universe.index(
                      stock)+1, '/', len(self.universe))

          self.universe = list(self.ini_dic.keys())

          try:
              data = ssdata.get_data(secid=self.benchmark,
                                     start_date=self.start_date,
                                     end_date=self.end_date,
                                     field='open').sort_index().dropna()
              self.benchmark_data = self.benchmark_data.append(data)
          except Exception:
              print("Benchmark ", self.benchmark, " data unavailable.")

          self.trade_days = self.benchmark_data.index
          self.order_days = self.get_order_days()

      def get_order_days(self):
          """
          Return the list of order days based on frequency.
          """
          tdays = list(self.trade_days)
          odays = []
          for i in range(len(tdays)):
              if i % self.freq == 0:
                  odays.append(tdays[i])
          return odays


  start_date = '2015-07-01'
  end_date = '2018-06-01'
  capital_base = 1000000
  freq = 1
  benchmark = ['430002.OC']
  universe = list(pd.read_csv("All stocks.csv")['secid'])


  account = account(start_date=start_date, end_date=end_date,
                    capital_base=capital_base, freq=freq,
                    benchmark=benchmark, universe=universe)
  account.setup()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[23]:
:END:

* Trade (not considering liquidity)

#+BEGIN_SRC ipython :preamble "# -*- coding: utf-8 -*-" :ipyfile /tmp/image.png :results raw drawer :session :async t
  %matplotlib inline

  global volume_each_month
  volume_each_month = list()
  account.today_capital = None
  # 存储收益情况的dataframe，索引是日期，列有策略收益率、基准收益率、最大回撤、
  # 最大回撤区间
  account.ret = None
  # 历史最大回撤
  account.history_max = None
  # 历史最大回撤区间起始日
  account.drawdown_start = None
  # 历史最大回撤区间终止日
  account.drawdown_end = None
  # 存储每个交易日总资产的列表
  account.capital = None
  # 现金
  account.cash = None

  account.ret = pd.DataFrame()
  account.history_max = 0
  account.capital = []
  account.cash = account.capital_base


  h_amount = pd.DataFrame({'hamount': [0],
                           'price': [0],
                           'value': [0],
                           'percent': [0]}, index=account.universe)
  # selected = pd.DataFrame()


  def order_to(target):
      """
      下单到多少股。
      """
      global h_amount
      trade_days = account.trade_days
      order_days = account.order_days
      tax = account.tax
      commission = account.commission
      ini_dic = account.ini_dic
      today_capital = account.today_capital
      slippage = account.slippage

      # 如果date在下单日，就需要进行调仓
      if date in order_days:
          # print(date.strftime('%Y-%m-%d'), list(target.index))
          # t_amount是目标仓位数据的dataframe
          t_amount = pd.DataFrame({'tamount': [0]}, index=list(target.index))

          # Sell stocks in holding but not in target
          for stock in list(h_amount.index):
              if stock not in list(target.index):
                  try:
                      stock_data = ini_dic[stock].loc[date.strftime("%Y-%m-%d")]
                      price = stock_data['open']
                      account.cash += h_amount.loc[stock, 'hamount'] *\
                          (price-slippage) * (1-tax-commission)
                      # print('order: ', stock, 'amount ',
                      #       int(0-h_amount.loc[stock, 'hamount']))
                      h_amount.loc[stock, 'hamount'] = -1
                  except Exception:
                      h_amount.loc[stock, 'hamount'] = -1
          h_amount = h_amount[h_amount['hamount'] != -1]
          # print("cash: ", account.cash)

          # Deal with stocks in target
          for stock in list(target.index):
              stock_data = ini_dic[stock].loc[date.strftime(
                  "%Y-%m-%d")].fillna(0)
              price = stock_data['open']
              # price = stock_data.loc[date.strftime('%Y-%m-%d'), 'open']

              # Buy stocks in target but not in holding
              if stock not in list(h_amount.index):
                  h_amount = h_amount.append(pd.DataFrame({'hamount': [0],
                                                           'price': [0],
                                                           'value': [0],
                                                           'percent': [0]},
                                                          index=[stock]))
              # print(target)
              t_amount.loc[stock, 'tamount'] = math.floor(target[stock]/100)*100

              # If hoding > target, sell
              if h_amount.loc[stock, 'hamount'] - t_amount.loc[stock, 'tamount']\
                 > 0:
                  account.cash += (h_amount.loc[stock, 'hamount'] -
                                   t_amount.loc[stock, 'tamount'])\
                                   ,* (price-slippage) * (1-tax-commission)

              # If hoding < target, buy
              if h_amount.loc[stock, 'hamount'] - t_amount.loc[stock, 'tamount']\
                 < 0:
                  # Attention: buy hand by hand in case cash becomes negative
                  for number in range(int(t_amount.loc[stock, 'tamount']/100),
                                      0, -1):
                      if account.cash - (number*100 -
                                         h_amount.loc[stock, 'hamount']) *\
                                         (price+slippage) * (1+commission) < 0:
                          continue
                      else:
                          account.cash -= (number*100 -
                                           h_amount.loc[stock, 'hamount']) *\
                                           (price+slippage) * (1+commission)
                          t_amount.loc[stock, 'tamount'] = number * 100
                          break

              # if h_amount.loc[stock, 'hamount'] - t_amount.loc[stock, 'tamount']\
              #    != 0:
              #     print('order: ', stock, 'amount ',
              #           int(t_amount.loc[stock, 'tamount'] -
              #               h_amount.loc[stock, 'hamount']))

              h_amount.loc[stock, 'hamount'] = t_amount.loc[stock, 'tamount']
              h_amount.loc[stock, 'price'] = price
              h_amount.loc[stock, 'value'] = h_amount.loc[stock, 'price'] *\
                  h_amount.loc[stock, 'hamount']

          h_amount['percent'] = h_amount['value'] / sum(h_amount['value'])

      # # Output holding details
      # h_amount.to_csv('position_details.csv')

      account.capital.append(today_capital)
      try:
          drawdown = (max(account.capital[:-1])-account.capital[-1]) /\
              max(account.capital[:-1])
      except Exception:
          drawdown = 0

      if drawdown > account.history_max:
          account.drawdown_start =\
              trade_days[account.capital.index(max(account.capital[:-1]))]
          account.drawdown_end =\
              trade_days[account.capital.index(account.capital[-1])]
          account.history_max = drawdown

      account.ret = account.ret.append(pd.DataFrame(
          {'rev': (account.capital[-1]-account.capital[0])/account.capital[0],
           'max_drawdown': account.history_max,
           'benchmark':
           (account.benchmark_data.loc[date.strftime('%Y-%m-%d'), 'open'] -
            account.benchmark_data.loc[trade_days[0].strftime('%Y-%m-%d'),
                                       'open']) /
           account.benchmark_data.loc[trade_days[0].strftime('%Y-%m-%d'),
                                      'open']},
          index=[date]))


  def order_pct_to(pct_target):
      """
      下单到多少百分比。
      """
      ini_dic = account.ini_dic
      today_capital = account.today_capital
      # target是存储目标股数的Series
      target = pd.Series()

      # 将pct_target中的仓位百分比数据转化为target中的股数
      for stock in list(pct_target.index):
          stock_data = ini_dic[stock].loc[date.strftime("%Y-%m-%d")]
          price = stock_data['open']
          # price = stock_data.loc[date.strftime('%Y-%m-%d'), 'open']
          # print("today_capital: ", today_capital)
          target[stock] = (pct_target[stock]*today_capital) / price

      # 调用order_to函数
      order_to(target)


  def result_display(account):
      """
      Display results, including the return curve and a table showing returns
      drawdown and drawdown intervals.
      """
      # account.ret.to_csv('return_details.csv')
      # strategy annual return
      Ra = (1+(account.ret.iloc[-1].rev)) **\
          (12/len(list(account.trade_days))) - 1
      results = pd.DataFrame({'benchmark return':
                              '%.2f%%' % (account.ret.iloc[-1].benchmark * 100),
                              'Strategy return':
                              '%.2f%%' % (account.ret.iloc[-1].rev * 100),
                              'Strategy annual return':
                              '%.2f%%' % (Ra*100),
                              'Max drawdown':
                              '%.2f%%' % (account.ret.iloc[-1].max_drawdown*100),
                              'Max drawdown interval':
                              str(account.drawdown_start.strftime('%Y-%m-%d')
                                  + ' to '
                                  + account.drawdown_end.strftime('%Y-%m-%d'))},
                             index=[''])
      results.reindex(['benchmark return',
                       'Strategy return',
                       'Strategy annual return',
                       'Max drawdown'
                       'Max drawdown interval'], axis=1)
      print(results.transpose())

      # plot the results
      account.ret['rev'].plot(color='royalblue', label='strategy return')
      account.ret['benchmark'].plot(color='black', label='benchmark return')
      x = np.array(list(account.ret.index))
      plt.fill_between(x, max(max(account.ret.rev), max(account.ret.benchmark)),
                       min(min(account.ret.rev), min(account.ret.benchmark)),
                       where=((x <= account.drawdown_end) &
                              (x >= account.drawdown_start)),
                       facecolor='lightsteelblue',
                       alpha=0.4)
      plt.legend()
      plt.show()


  ###############################################################################
  #                   Parameters and functions set up manually                  #
  ###############################################################################


  def initialize(account):
      """
      This is a function that runs only once, before the backtest begins.
      """
      pass


  def stock_filter(account):
      """
      根据yoyop进行选股的函数。选yoyop前n的股票。
      """
      # 将date这一交易日的股票数据取出存到一个新的dataframe中
      all_stock_df = pd.DataFrame()
      amount_information = pd.read_csv(
          'amount_information1.csv', index_col="secid")
      # 遍历ini_dic中所有的股票
      for stock in list(account.ini_dic.keys()):
          # 将date这一天的数据存入all_stock_df中，去掉无数据的
          try:
              all_stock_df = all_stock_df.append(
                  account.ini_dic[stock].loc[date.strftime('%Y-%m-%d')])
          except Exception:
              pass

      # 按yoyop降序排序
      all_stock_df = all_stock_df.sort_values('yoyop', ascending=False).set_index('secid')
      # 取前n支股票
      selected_stock_df = all_stock_df[:100]
      # 增加交易额
      selected_stock_df['amount'] = None
      for stock in selected_stock_df.index:
          selected_stock_df['amount'][stock] = amount_information.loc[
              stock, date.strftime('%Y-%m-%d')]
      # 取交易额之和的十分之一作为该月的策略容量
      volume_each_month.append(sum(selected_stock_df['amount']) / 10)
      # 将选取的股票代码存入buylist
      buylist = selected_stock_df.index
      # 输出选股情况
      print(date.strftime('%Y-%m-%d'), "selected stocks: ", list(buylist))
      # selected = selected.append(pd.DataFrame(
      #     {"selected stocks": str(buylist)}, index=[date.strftime('%Y-%m-%d')]))
      return buylist


  def handle_data(account):
      """
      This is a function that runs every backtest frequency.
      """
      # selected_stocks为上述选股函数选出的函数
      selected_stocks = stock_filter(account)
      # print(selected_stocks)
      # positions为声明的一个存储目票仓位情况的Series
      positions = pd.Series()
      # 这里采用平均配仓的方式
      for stock in selected_stocks:
          positions[stock] = 1/len(selected_stocks)
          # 将仓位传入下单函数进行下单
      order_pct_to(positions)


  for date in list(account.trade_days):
      account.today_capital = 0
      for stock in list(h_amount.index):
          try:
              stock_data = account.ini_dic[stock].loc[date.strftime(
                  "%Y-%m-%d")].fillna(0)
              price = stock_data['open']
              account.today_capital += price * h_amount.loc[stock, 'hamount']
          except Exception:
              pass
      account.today_capital += account.cash

      handle_data(account)

  result_display(account)

  volume_final = min(volume_each_month)
  # volumes = list([min(volume_each_month[:12]), min(
  #     volume_each_month[12:24]), min(volume_each_month[24:])])
  # print("volume_each_month:", volume_each_month)
  print("Market volume(1 year): ", volume_final)
  # print("Market volume(3 years): ", volume_final)
  # print("Market volume(2015.7 - 2016.6: ", volumes[0])
  # print("Market volume(2016.7 - 2017.6: ", volumes[1])
  # print("Market volume(2017.7 - 2018.6: ", volumes[2])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[40]:
[[file:/tmp/image.png]]
:END:

* Trade (considering liquidity)

#+BEGIN_SRC ipython :preamble "# -*- coding: utf-8 -*-" :ipyfile /tmp/image.png :results raw drawer :session :async t
  %matplotlib inline

  global volume_each_month
  volume_each_month = list()
  account.today_capital = None
  # 存储收益情况的dataframe，索引是日期，列有策略收益率、基准收益率、最大回撤、
  # 最大回撤区间
  account.ret = None
  # 历史最大回撤
  account.history_max = None
  # 历史最大回撤区间起始日
  account.drawdown_start = None
  # 历史最大回撤区间终止日
  account.drawdown_end = None
  # 存储每个交易日总资产的列表
  account.capital = None
  # 现金
  account.cash = None

  account.ret = pd.DataFrame()
  account.history_max = 0
  account.capital = []
  account.cash = account.capital_base


  h_amount = pd.DataFrame({'hamount': [0],
                           'price': [0],
                           'value': [0],
                           'percent': [0]}, index=account.universe)
  # selected = pd.DataFrame()


  def order_to(target):
      """
      下单到多少股。
      """
      global h_amount
      trade_days = account.trade_days
      order_days = account.order_days
      tax = account.tax
      commission = account.commission
      ini_dic = account.ini_dic
      today_capital = account.today_capital
      slippage = account.slippage

      # 如果date在下单日，就需要进行调仓
      if date in order_days:
          # print(date.strftime('%Y-%m-%d'), list(target.index))
          # t_amount是目标仓位数据的dataframe
          t_amount = pd.DataFrame({'tamount': [0]}, index=list(target.index))

          # Sell stocks in holding but not in target
          for stock in list(h_amount.index):
              if stock not in list(target.index):
                  try:
                      stock_data = ini_dic[stock].loc[date.strftime("%Y-%m-%d")]
                      price = stock_data['open']
                      account.cash += h_amount.loc[stock, 'hamount'] *\
                          (price-slippage) * (1-tax-commission)
                      # print('order: ', stock, 'amount ',
                      #       int(0-h_amount.loc[stock, 'hamount']))
                      h_amount.loc[stock, 'hamount'] = -1
                  except Exception:
                      h_amount.loc[stock, 'hamount'] = -1
          h_amount = h_amount[h_amount['hamount'] != -1]
          # print("cash: ", account.cash)

          # Deal with stocks in target
          for stock in list(target.index):
              stock_data = ini_dic[stock].loc[date.strftime(
                  "%Y-%m-%d")].fillna(0)
              price = stock_data['open']
              # price = stock_data.loc[date.strftime('%Y-%m-%d'), 'open']

              # Buy stocks in target but not in holding
              if stock not in list(h_amount.index):
                  h_amount = h_amount.append(pd.DataFrame({'hamount': [0],
                                                           'price': [0],
                                                           'value': [0],
                                                           'percent': [0]},
                                                          index=[stock]))
              # print(target)
              t_amount.loc[stock, 'tamount'] = math.floor(target[stock]/100)*100

              # If hoding > target, sell
              if h_amount.loc[stock, 'hamount'] - t_amount.loc[stock, 'tamount']\
                 > 0:
                  account.cash += (h_amount.loc[stock, 'hamount'] -
                                   t_amount.loc[stock, 'tamount'])\
                                   ,* (price-slippage) * (1-tax-commission)

              # If hoding < target, buy
              if h_amount.loc[stock, 'hamount'] - t_amount.loc[stock, 'tamount']\
                 < 0:
                  # Attention: buy hand by hand in case cash becomes negative
                  for number in range(int(t_amount.loc[stock, 'tamount']/100),
                                      0, -1):
                      if account.cash - (number*100 -
                                         h_amount.loc[stock, 'hamount']) *\
                                         (price+slippage) * (1+commission) < 0:
                          continue
                      else:
                          account.cash -= (number*100 -
                                           h_amount.loc[stock, 'hamount']) *\
                                           (price+slippage) * (1+commission)
                          t_amount.loc[stock, 'tamount'] = number * 100
                          break

              # if h_amount.loc[stock, 'hamount'] - t_amount.loc[stock, 'tamount']\
              #    != 0:
              #     print('order: ', stock, 'amount ',
              #           int(t_amount.loc[stock, 'tamount'] -
              #               h_amount.loc[stock, 'hamount']))

              h_amount.loc[stock, 'hamount'] = t_amount.loc[stock, 'tamount']
              h_amount.loc[stock, 'price'] = price
              h_amount.loc[stock, 'value'] = h_amount.loc[stock, 'price'] *\
                  h_amount.loc[stock, 'hamount']

          h_amount['percent'] = h_amount['value'] / sum(h_amount['value'])

      # # Output holding details
      # h_amount.to_csv('position_details.csv')

      account.capital.append(today_capital)
      try:
          drawdown = (max(account.capital[:-1])-account.capital[-1]) /\
              max(account.capital[:-1])
      except Exception:
          drawdown = 0

      if drawdown > account.history_max:
          account.drawdown_start =\
              trade_days[account.capital.index(max(account.capital[:-1]))]
          account.drawdown_end =\
              trade_days[account.capital.index(account.capital[-1])]
          account.history_max = drawdown

      account.ret = account.ret.append(pd.DataFrame(
          {'rev': (account.capital[-1]-account.capital[0])/account.capital[0],
           'max_drawdown': account.history_max,
           'benchmark':
           (account.benchmark_data.loc[date.strftime('%Y-%m-%d'), 'open'] -
            account.benchmark_data.loc[trade_days[0].strftime('%Y-%m-%d'),
                                       'open']) /
           account.benchmark_data.loc[trade_days[0].strftime('%Y-%m-%d'),
                                      'open']},
          index=[date]))


  def order_pct_to(pct_target):
      """
      下单到多少百分比。
      """
      ini_dic = account.ini_dic
      today_capital = account.today_capital
      # target是存储目标股数的Series
      target = pd.Series()

      # 将pct_target中的仓位百分比数据转化为target中的股数
      for stock in list(pct_target.index):
          stock_data = ini_dic[stock].loc[date.strftime("%Y-%m-%d")]
          price = stock_data['open']
          # price = stock_data.loc[date.strftime('%Y-%m-%d'), 'open']
          # print("today_capital: ", today_capital)
          target[stock] = (pct_target[stock]*today_capital) / price

      # 调用order_to函数
      order_to(target)


  def result_display(account):
      """
      Display results, including the return curve and a table showing returns
      drawdown and drawdown intervals.
      """
      # account.ret.to_csv('return_details.csv')
      # strategy annual return
      Ra = (1+(account.ret.iloc[-1].rev)) **\
          (12/len(list(account.trade_days))) - 1
      results = pd.DataFrame({'benchmark return':
                              '%.2f%%' % (account.ret.iloc[-1].benchmark * 100),
                              'Strategy return':
                              '%.2f%%' % (account.ret.iloc[-1].rev * 100),
                              'Strategy annual return':
                              '%.2f%%' % (Ra*100),
                              'Max drawdown':
                              '%.2f%%' % (account.ret.iloc[-1].max_drawdown*100),
                              'Max drawdown interval':
                              str(account.drawdown_start.strftime('%Y-%m-%d')
                                  + ' to '
                                  + account.drawdown_end.strftime('%Y-%m-%d'))},
                             index=[''])
      results.reindex(['benchmark return',
                       'Strategy return',
                       'Strategy annual return',
                       'Max drawdown'
                       'Max drawdown interval'], axis=1)
      print(results.transpose())

      # plot the results
      account.ret['rev'].plot(color='royalblue', label='strategy return')
      account.ret['benchmark'].plot(color='black', label='benchmark return')
      x = np.array(list(account.ret.index))
      plt.fill_between(x, max(max(account.ret.rev), max(account.ret.benchmark)),
                       min(min(account.ret.rev), min(account.ret.benchmark)),
                       where=((x <= account.drawdown_end) &
                              (x >= account.drawdown_start)),
                       facecolor='lightsteelblue',
                       alpha=0.4)
      plt.legend()
      plt.show()


  ###############################################################################
  #                   Parameters and functions set up manually                  #
  ###############################################################################


  def initialize(account):
      """
      This is a function that runs only once, before the backtest begins.
      """
      pass


  def stock_filter(account):
      """
      根据yoyop进行选股的函数。选yoyop前n的股票。
      """
      # global selected
      # 将date这一交易日的股票数据取出存到一个新的dataframe中
      all_stock_df = pd.DataFrame()
      mktmaker_information = pd.read_csv(
          'market_maker_information1.csv', index_col="secid")
      amount_information = pd.read_csv(
          'amount_information1.csv', index_col="secid")
      # 遍历ini_dic中所有的股票
      for stock in list(account.ini_dic.keys()):
          # 将date这一天的数据存入all_stock_df中，去掉无数据的
          if mktmaker_information.loc[stock, date.strftime('%Y-%m-%d')] == 1 and\
             amount_information.loc[stock, date.strftime('%Y-%m-%d')] >= 1000000:
              try:
                  all_stock_df = all_stock_df.append(
                      account.ini_dic[stock].loc[date.strftime('%Y-%m-%d')])
              except Exception:
                  pass

      # 按yoyop降序排序
      all_stock_df = all_stock_df.sort_values('yoyop', ascending=False).set_index('secid')
      # 取前n支股票
      selected_stock_df = all_stock_df[:5]
      # 增加交易额
      selected_stock_df['amount'] = None
      for stock in selected_stock_df.index:
          selected_stock_df['amount'][stock] = amount_information.loc[
              stock, date.strftime('%Y-%m-%d')]
      # 取交易额之和的十分之一作为该月的策略容量
      volume_each_month.append(sum(selected_stock_df['amount']) / 10)
      # 将选取的股票代码存入buylist
      buylist = selected_stock_df.index
      # 输出选股情况
      print(date.strftime('%Y-%m-%d'), "selected stocks: ", list(buylist))
      # selected = selected.append(pd.DataFrame(
      #     {"selected stocks": str(buylist)}, index=[date.strftime('%Y-%m-%d')]))
      return buylist


  def handle_data(account):
      """
      This is a function that runs every backtest frequency.
      """
      # selected_stocks为上述选股函数选出的函数
      selected_stocks = stock_filter(account)
      # print(selected_stocks)
      # positions为声明的一个存储目票仓位情况的Series
      positions = pd.Series()
      # 这里采用平均配仓的方式
      for stock in selected_stocks:
          positions[stock] = 1/len(selected_stocks)
          # 将仓位传入下单函数进行下单
      order_pct_to(positions)


  for date in list(account.trade_days):
      account.today_capital = 0
      for stock in list(h_amount.index):
          try:
              stock_data = account.ini_dic[stock].loc[date.strftime(
                  "%Y-%m-%d")].fillna(0)
              price = stock_data['open']
              account.today_capital += price * h_amount.loc[stock, 'hamount']
          except Exception:
              pass
      account.today_capital += account.cash

      handle_data(account)

  result_display(account)

  volume_final = min(volume_each_month)
  # volumes = list([min(volume_each_month[:12]), min(
  #     volume_each_month[12:24]), min(volume_each_month[24:])])
  # print("volume_each_month:", volume_each_month)
  print("Market volume(1 year): ", volume_final)
  # print("Market volume(3 years): ", volume_final)
  # print("Market volume(2015.7 - 2016.6: ", volumes[0])
  # print("Market volume(2016.7 - 2017.6: ", volumes[1])
  # print("Market volume(2017.7 - 2018.6: ", volumes[2])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[6]:
[[file:/tmp/image.png]]
:END:


* Trade (with pb market-timing, considering liquidity)

#+BEGIN_SRC ipython :preamble "# -*- coding: utf-8 -*-" :ipyfile /tmp/image.png :results raw drawer :session :async t
  import datetime
  %matplotlib inline

  global volume_each_month
  volume_each_month = list()
  account.today_capital = None
  # 存储收益情况的dataframe，索引是日期，列有策略收益率、基准收益率、最大回撤、
  # 最大回撤区间
  account.ret = None
  # 历史最大回撤
  account.history_max = None
  # 历史最大回撤区间起始日
  account.drawdown_start = None
  # 历史最大回撤区间终止日
  account.drawdown_end = None
  # 存储每个交易日总资产的列表
  account.capital = None
  # 现金
  account.cash = None

  account.ret = pd.DataFrame()
  account.history_max = 0
  account.capital = []
  account.cash = account.capital_base


  h_amount = pd.DataFrame({'hamount': [0],
                           'price': [0],
                           'value': [0],
                           'percent': [0]}, index=account.universe)
  # selected = pd.DataFrame()


  def order_to(target):
      """
      下单到多少股。
      """
      global h_amount
      trade_days = account.trade_days
      order_days = account.order_days
      tax = account.tax
      commission = account.commission
      ini_dic = account.ini_dic
      today_capital = account.today_capital
      slippage = account.slippage

      # 如果date在下单日，就需要进行调仓
      if date in order_days:
          # print(date.strftime('%Y-%m-%d'), list(target.index))
          # t_amount是目标仓位数据的dataframe
          t_amount = pd.DataFrame({'tamount': [0]}, index=list(target.index))

          # Sell stocks in holding but not in target
          for stock in list(h_amount.index):
              if stock not in list(target.index):
                  try:
                      stock_data = ini_dic[stock].loc[date.strftime("%Y-%m-%d")]
                      price = stock_data['open']
                      account.cash += h_amount.loc[stock, 'hamount'] *\
                          (price-slippage) * (1-tax-commission)
                      # print('order: ', stock, 'amount ',
                      #       int(0-h_amount.loc[stock, 'hamount']))
                      h_amount.loc[stock, 'hamount'] = -1
                  except Exception:
                      h_amount.loc[stock, 'hamount'] = -1
          h_amount = h_amount[h_amount['hamount'] != -1]
          # print("cash: ", account.cash)

          # Deal with stocks in target
          for stock in list(target.index):
              stock_data = ini_dic[stock].loc[date.strftime(
                  "%Y-%m-%d")].fillna(0)
              price = stock_data['open']
              # price = stock_data.loc[date.strftime('%Y-%m-%d'), 'open']

              # Buy stocks in target but not in holding
              if stock not in list(h_amount.index):
                  h_amount = h_amount.append(pd.DataFrame({'hamount': [0],
                                                           'price': [0],
                                                           'value': [0],
                                                           'percent': [0]},
                                                          index=[stock]))
              # print(target)
              t_amount.loc[stock, 'tamount'] = math.floor(target[stock]/100)*100

              # If hoding > target, sell
              if h_amount.loc[stock, 'hamount'] - t_amount.loc[stock, 'tamount']\
                 > 0:
                  account.cash += (h_amount.loc[stock, 'hamount'] -
                                   t_amount.loc[stock, 'tamount'])\
                                   ,* (price-slippage) * (1-tax-commission)

              # If hoding < target, buy
              if h_amount.loc[stock, 'hamount'] - t_amount.loc[stock, 'tamount']\
                 < 0:
                  # Attention: buy hand by hand in case cash becomes negative
                  for number in range(int(t_amount.loc[stock, 'tamount']/100),
                                      0, -1):
                      if account.cash - (number*100 -
                                         h_amount.loc[stock, 'hamount']) *\
                                         (price+slippage) * (1+commission) < 0:
                          continue
                      else:
                          account.cash -= (number*100 -
                                           h_amount.loc[stock, 'hamount']) *\
                                           (price+slippage) * (1+commission)
                          t_amount.loc[stock, 'tamount'] = number * 100
                          break

              # if h_amount.loc[stock, 'hamount'] - t_amount.loc[stock, 'tamount']\
              #    != 0:
              #     print('order: ', stock, 'amount ',
              #           int(t_amount.loc[stock, 'tamount'] -
              #               h_amount.loc[stock, 'hamount']))

              h_amount.loc[stock, 'hamount'] = t_amount.loc[stock, 'tamount']
              h_amount.loc[stock, 'price'] = price
              h_amount.loc[stock, 'value'] = h_amount.loc[stock, 'price'] *\
                  h_amount.loc[stock, 'hamount']

          h_amount['percent'] = h_amount['value'] / sum(h_amount['value'])

      # # Output holding details
      # h_amount.to_csv('position_details.csv')

      account.capital.append(today_capital)
      try:
          drawdown = (max(account.capital[:-1])-account.capital[-1]) /\
              max(account.capital[:-1])
      except Exception:
          drawdown = 0

      if drawdown > account.history_max:
          account.drawdown_start =\
              trade_days[account.capital.index(max(account.capital[:-1]))]
          account.drawdown_end =\
              trade_days[account.capital.index(account.capital[-1])]
          account.history_max = drawdown

      account.ret = account.ret.append(pd.DataFrame(
          {'rev': (account.capital[-1]-account.capital[0])/account.capital[0],
           'max_drawdown': account.history_max,
           'benchmark':
           (account.benchmark_data.loc[date.strftime('%Y-%m-%d'), 'open'] -
            account.benchmark_data.loc[trade_days[0].strftime('%Y-%m-%d'),
                                       'open']) /
           account.benchmark_data.loc[trade_days[0].strftime('%Y-%m-%d'),
                                      'open']},
          index=[date]))


  def order_pct_to(pct_target):
      """
      下单到多少百分比。
      """
      ini_dic = account.ini_dic
      today_capital = account.today_capital
      # target是存储目标股数的Series
      target = pd.Series()

      # 将pct_target中的仓位百分比数据转化为target中的股数
      for stock in list(pct_target.index):
          stock_data = ini_dic[stock].loc[date.strftime("%Y-%m-%d")]
          price = stock_data['open']
          # price = stock_data.loc[date.strftime('%Y-%m-%d'), 'open']
          # print("today_capital: ", today_capital)
          target[stock] = (pct_target[stock]*today_capital) / price

      # 调用order_to函数
      order_to(target)


  def result_display(account):
      """
      Display results, including the return curve and a table showing returns
      drawdown and drawdown intervals.
      """
      # account.ret.to_csv('return_details.csv')
      # strategy annual return
      Ra = (1+(account.ret.iloc[-1].rev)) **\
          (12/len(list(account.trade_days))) - 1
      results = pd.DataFrame({'benchmark return':
                              '%.2f%%' % (account.ret.iloc[-1].benchmark * 100),
                              'Strategy return':
                              '%.2f%%' % (account.ret.iloc[-1].rev * 100),
                              'Strategy annual return':
                              '%.2f%%' % (Ra*100),
                              'Max drawdown':
                              '%.2f%%' % (account.ret.iloc[-1].max_drawdown*100),
                              'Max drawdown interval':
                              str(account.drawdown_start.strftime('%Y-%m-%d')
                                  + ' to '
                                  + account.drawdown_end.strftime('%Y-%m-%d'))},
                             index=[''])
      results.reindex(['benchmark return',
                       'Strategy return',
                       'Strategy annual return',
                       'Max drawdown'
                       'Max drawdown interval'], axis=1)
      print(results.transpose())

      # plot the results
      account.ret['rev'].plot(color='royalblue', label='strategy return')
      account.ret['benchmark'].plot(color='black', label='benchmark return')
      x = np.array(list(account.ret.index))
      plt.fill_between(x, max(max(account.ret.rev), max(account.ret.benchmark)),
                       min(min(account.ret.rev), min(account.ret.benchmark)),
                       where=((x <= account.drawdown_end) &
                              (x >= account.drawdown_start)),
                       facecolor='lightsteelblue',
                       alpha=0.4)
      plt.legend()
      plt.show()


  ###############################################################################
  #                   Parameters and functions set up manually                  #
  ###############################################################################


  def initialize(account):
      """
      This is a function that runs only once, before the backtest begins.
      """
      account.signal = False  # 空仓信号
      account.buy = True  # 买入信号


  def MarketSignal(account):
      """
      Empty positions when market PB is too high.
      """
      last_date = list(account.trade_days)[list(account.trade_days).index(date)-1]
      df = pd.DataFrame()
      for stock in list(account.ini_dic.keys()):
          stock_data = account.ini_dic[stock]
          try:
              df = df.append(pd.DataFrame(
                  {"pb": stock_data.loc[last_date.strftime("%Y-%m-%d"), "pb"]},
                  index=[stock_data.loc[last_date.strftime("%Y-%m-%d"), "secid"]]))
          except Exception:
              pass

      factor_quantiles = df.dropna().quantile([0.8])
      PB = factor_quantiles.iloc[0].values

      print(last_date.strftime("%Y-%m-%d"), "PB:", PB)
      if PB >= 10:
          return 120, 'PB_long'  # 长空仓
      else:
          return 0, False


  def stock_filter(account):
      """
      根据yoyop进行选股的函数。选yoyop前n的股票。
      """
      # global selected
      # 将date这一交易日的股票数据取出存到一个新的dataframe中
      all_stock_df = pd.DataFrame()
      mktmaker_information = pd.read_csv(
          'market_maker_information1.csv', index_col="secid")
      amount_information = pd.read_csv(
          'amount_information1.csv', index_col="secid")
      # 遍历ini_dic中所有的股票
      for stock in list(account.ini_dic.keys()):
          # 将date这一天的数据存入all_stock_df中，去掉无数据的
          if mktmaker_information.loc[stock, date.strftime('%Y-%m-%d')] == 1 and\
             amount_information.loc[stock, date.strftime('%Y-%m-%d')] >= 1000000:
              try:
                  all_stock_df = all_stock_df.append(
                      account.ini_dic[stock].loc[date.strftime('%Y-%m-%d')])
              except Exception:
                  pass

      # 按yoyop降序排序
      all_stock_df = all_stock_df.sort_values('yoyop', ascending=False).set_index('secid')
      # 取前n支股票
      selected_stock_df = all_stock_df[:10]
      # 增加交易额
      selected_stock_df['amount'] = None
      for stock in selected_stock_df.index:
          selected_stock_df['amount'][stock] = amount_information.loc[
              stock, date.strftime('%Y-%m-%d')]
      # 取交易额之和的十分之一作为该月的策略容量
      volume_each_month.append(sum(selected_stock_df['amount']) / 10)
      # 将选取的股票代码存入buylist
      buylist = selected_stock_df.index
      # 输出选股情况
      print(date.strftime('%Y-%m-%d'), "selected stocks: ", list(buylist))
      # selected = selected.append(pd.DataFrame(
      #     {"selected stocks": str(buylist)}, index=[date.strftime('%Y-%m-%d')]))
      return buylist


  def handle_data(account):
      positions = pd.Series()
      # 如果不在PB长空仓期
      if account.signal != 'PB_long':
          # 检测空仓信号
          period, account.signal = MarketSignal(account)
          # 如果有空仓信号
          if account.signal is not False:
              # 更改买入信号为False
              account.buy = False
              # 计算空仓结束时间
              account.end_date = date + datetime.timedelta(days=period)
              # 执行空仓
              for stock in list(h_amount.index):
                  positions[stock] = 0
              order_pct_to(positions)
              # 输出信号
              print('空仓信号在' + date.strftime('%Y-%m-%d') +
                    '触发，空仓' + str(period) + '天')

      # 如果买入信号为假，现在日期大于空仓停止日期
      if account.buy is False and date > account.end_date:
          # 空仓期结束
          account.buy = True  # 买入
          account.signal = False  # 无信号

      # 买入信号为真
      if account.buy is True:
          buylist = stock_filter(account)

          for stock in buylist:
              positions[stock] = 1/len(buylist)
          order_pct_to(positions)
      else:
          # 如果在空仓期，时间未结束
          pass


  initialize(account)
  for date in list(account.trade_days):
      account.today_capital = 0
      for stock in list(h_amount.index):
          try:
              stock_data = account.ini_dic[stock].loc[date.strftime(
                  "%Y-%m-%d")].fillna(0)
              price = stock_data['open']
              account.today_capital += price * h_amount.loc[stock, 'hamount']
          except Exception:
              pass
      account.today_capital += account.cash

      handle_data(account)

  result_display(account)

  volume_final = min(volume_each_month)
  # volumes = list([min(volume_each_month[:12]), min(
  #     volume_each_month[12:24]), min(volume_each_month[24:])])
  # print("volume_each_month:", volume_each_month)
  print("Market volume(1 year): ", volume_final)
  # print("Market volume(3 years): ", volume_final)
  # print("Market volume(2015.7 - 2016.6: ", volumes[0])
  # print("Market volume(2016.7 - 2017.6: ", volumes[1])
  # print("Market volume(2017.7 - 2018.6: ", volumes[2])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[30]:
[[file:/tmp/image.png]]
:END:

* test
#+BEGIN_SRC ipython :preamble "# -*- coding: utf-8 -*-" :results raw drawer :session :async t
  import ssdata
  import pandas

  d1 = ssdata.get_data(secid="430002.OC",
                       start_date="2015-07-01",
                       end_date="2018-06-01",
                       field="pb,open,yoyop").sort_index()

  print(d1)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[2]:
:END:
